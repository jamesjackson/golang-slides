{
    "title": "Polymer",
    "subtitle": "Does the web make sense now?",
    "hashtag": "#golang",
    "author": "Alexander “surma” Surma",
    "work": "nuboLAB, GDG Berlin Golang, OpenTechSchool",
    "email": "surma@opentechschool.org",
    "twitter": "surmair",
    "gplus": "surmair",
    "homepage": "http://github.com/surma"
}
<style>
    ol{
    }
    ol.huge {
        display: block;
    }
    ol.huge li:before {
        content: '→ ';
        color: rgba(255,0,0,0.5);
    }
    ol.huge li {
        font-size: 48px;
        line-height: 2em;
    }
    .small {
        font-size: 0.5em;
    }
</style>
<slide>
    <hgroup>
        <h2>What is Polymer?</h2>
        <h3>… and what is it not?</h3>
    </hgroup>
    <article>
        <iframe src="imgs/polymerarch.svg" class="reflect" style="height: 400px;"></iframe>
    </article>
</slide>
<slide>
    <hgroup>
        <h2>What is Polymer?</h2>
    </hgroup>
    <article>
        <p>
            <ol class="build huge">
                <li><b>“platform.js”</b>: Collection of polyfills</li>
                <li><b>“Polymer”</b>: Leightweight framework</li>
                <li><b>“Polymer-Project”</b>: Google project</li>
            </ol>
        </p>
        <p>
    </article>
</slide>
<slide>
    <hgroup>
        <h2>The Goal</h2>
    </hgroup>
    <article>
        Twitter Bootstrap:
        <pre class="prettyprint" data-lang="html">
            &lt;twbs-navbar&gt;
                &lt;a href="#"&gt;Home&lt;/a&gt;
                &lt;a href="#"&gt;About&lt;/a&gt;
                &lt;a href="#"&gt;Bacon&lt;/a&gt;
            &lt;/twbs-navbar&gt; </pre>

        Omnipresent spoiler tag:
        <pre class="prettyprint" data-lang="html">
            &lt;spoiler-tag&gt;He was dead all along&lt;/spoiler-tag&gt; </pre>
        <iframe style="height: 100px" src="code/polymer/spoiler.html"></iframe>
    </article>
</slide>
<slide>
    <hgroup>
        <h2>The Process</h2>
    </hgroup>
    <article>
        <ol class="build huge">
            <li>Define your scaffolding</li>
            <li>Controllably apply content & styles</li>
            <li>React to changes with lifecycle callbacks</li>
            <li>Define an API</li>
            <li>Package it</li>
        </ol>
    </article>
</slide>
<slide class="segue dark nobackground">
    <aside class="gdbar"><img src="static/ioslide/images/google_developers_icon_128.png"></aside>
    <hgroup class="auto-fadein">
        <h2>Browser Technolgoy</h2>
        <h3>… for the process</h3>
    </hgroup>
</slide>
<slide>
    <hgroup>
        <h2>“Define your scaffolding”</h2>
        <h3>Part 1</h3>
    </hgroup>
    <article>
        <b>Templates</b> are parsed but unrendered DOM trees which can be reused.
        <pre class="prettyprint" data-lang="html">
            &lt;template id="welcome"&gt;
                &lt;p&gt;Welcome!&lt;/p&gt;
                &lt;script&gt;
                    alert("I've been activated");
                &lt;/script&gt;
            &lt;/template&gt; </pre>
        <pre class="prettyprint" data-lang="javascript">
            var tpl = document.querySelector("#welcome");
            var clone = tpl.content.cloneNode(true);
            // Still no alert…
            document.querySelector('something').appendChild(clone);
            // Alert! </pre>
    </article>
</slide>
<slide>
    <hgroup>
        <h2>“Define your scaffolding”</h2>
        <h3>Support</h3>
    </hgroup>
    <article>
        <img src="imgs/polymer-caniuse-templates.png" class="reflect"§>
    </article>
</slide>
<slide>
    <hgroup>
        <h2>“Define your scaffolding”</h2>
        <h3>Part 2</h3>
    </hgroup>
    <article>
        <b>Shadow DOM</b> creates boundaries inside the document.
        <pre class="prettyprint" data-lang="html">
            &lt;video src="./bunny.webm" controls&gt;&lt;/video&gt; </pre>
        <iframe src="code/polymer/video.html" style="width: 100%; height: 200px;"></iframe>
        <a href="code/polymer/video.html" target="_blank" class="small">Frame Link</a>
    </article>
    <aside class="note">
        <section>
            <ul>
                <li>JS scoping, CSS scoping</li>
                <li>Synergy with templates</li>
            </ul>
        </section>
    </aside>
</slide>
<slide>
    <hgroup>
        <h2>“Controllably apply content & styles”</h2>
        <h3>Styling from the outside</h3>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="html">
            &lt;template&gt;
                &lt;h1 part="title"&gt;Some Title…&lt;/h1&gt;
                &lt;h2 part="subtitle"&gt;… with a subtitle&lt;/h2&gt;
            &lt;/template&gt;</pre>
        <pre class="prettyprint" data-lang="javascript">
            var tmpl = document.querySelector("template");
            var host = document.querySelector(".widget");
            var root = host.createShadowRoot();
            root.appendChild(tmpl.content.cloneNode(true)); </pre>
        <pre class="prettyprint" data-lang="css">
          .widget::part(title) { font-family: Courier; }
          .widget::part(subtitle) { font-style: italic; } </pre>
    </article>
    <aside class="note">
        <section>
            <ul>
                <li>Only descendants of Shadow Root will be rendered</li>
            </ul>
        </section>
    </aside>
</slide>
<slide>
    <hgroup>
        <h2>“Controllably apply content & styles”</h2>
        <h3>DOM from the outside</h3>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="html">
            &lt;template id="warningbox"&gt;
                &lt;h1&gt;Warning&lt;/h1&gt;
                &lt;content&gt;&lt;/content&gt;
            &lt;/template&gt; </pre>
        <pre class="prettyprint" data-lang="html">
            &lt;div class="warningbox"&gt;You did this and that wrong! noob.&lt;/div&gt; </pre>
    </article>
    <aside class="note">
        <section>
            <ul>
                <li></li>
            </ul>
        </section>
    </aside>
</slide>
<slide>
    <hgroup>
        <h2>“Controllably apply content & styles”</h2>
        <h3>DOM from the outside - part 2</h3>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="html">
            &lt;template id="messagebox"&gt;
                &lt;h1&gt;&lt;content select=".title"&gt;&lt;/content&gt;&lt;/h1&gt;
                &lt;content select=""&gt;&lt;/content&gt;
            &lt;/template&gt; </pre>
        <pre class="prettyprint" data-lang="html">
            &lt;div class="messagebox"&gt;
                &lt;span class="title"&gt;Warning&lt;/span&gt;
                You did this and that wrong! noob.
            &lt;/div&gt; </pre>
    </article>
    <aside class="note">
        <section>
            <ul>
                <li></li>
            </ul>
        </section>
    </aside>
</slide>
<slide>
    <hgroup>
        <h2>“Controllably apply content & styles”</h2>
        <h3>Support</h3>
    </hgroup>
    <article>
        <img src="imgs/polymer-caniuse-shadowdom.png" class="reflect">
    </article>
</slide>
<slide>
    <hgroup>
        <h2>“Controllably apply content & styles”</h2>
    </hgroup>
    <article>
        <b>Shadow DOM</b> creates boundaries inside the document.
        <pre class="prettyprint" data-lang="html">
            &lt;video src="./bunny.webm" controls&gt;&lt;/video&gt;
        </pre>
        <iframe src="code/polymer/video.html" style="width: 100%; height: 200px;"></iframe>
        <a href="code/polymer/video.html" target="_blank" class="small">Frame Link</a>
    </article>
    <aside class="note">
        <section>
            <ul>
                <li>JS scoping, CSS scoping</li>
                <li>Synergy with templates</li>
            </ul>
        </section>
    </aside>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="go">
// Single line comment
/* Multi-
   line comment */
        </pre>
    </article>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="go">
// A “package” clause starts every source file.
// “main” is a special package name declaring an executable
// rather than a library.
package main
        </pre>
    </article>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="go">
package main

// Import declaration declares library packages referenced in this file.
import (
    "fmt"      // A package in the Go standard library
    "net/http" // Yes, a web server!
    "strconv"  // String conversions
)
        </pre>
    </article>
    <aside class="note">
        <section>
            Yes, Go will punch you if you have unused imports. Get used to it.
        </section>
    </aside>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="go">
package main

import (
    "fmt"
)

// A function definition.  Main is special.  It is the entry point for the
// executable program.  Love it or hate it, Go uses brace brackets.
func main() {
    // Println outputs a line to stdout.
    fmt.Println("Hello world!")

    // Call another function within this package.
    beyondHello()
}

        </pre>
    </article>
    <aside class="note">
        <section>
            <ul>
                <li>UTF8</li>
                <li>No semicoli</li>
            </ul>
        </section>
    </aside>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="go">
// Functions have parameters in parentheses.
// If there are no parameters, empty parentheses are still required.
func beyondHello() {
    var x int // Variable declaration.  Variables must be declared before use.
    x = 3     // Variable assignment.
    // “Short” declarations use := to infer the type, declare, and assign.
    y := 4
    sum, prod := learnMultiple(x, y)        // function returns two values
    fmt.Println("sum:", sum, "prod:", prod)
    learnTypes()
}

// Functions can have parameters and (multiple!) return values.
func learnMultiple(x, y int) (sum, prod int) {
    return x + y, x * y // return two values
}
        </pre>
    </article>
    <aside class="note">
        <section>
            <ul>
                <li>“Before use” vs. “Head of function”</li>
                <li>Inference</li>
                <li><code>printf</code></li>
                <li>Type signature backwards? Think about typedefs.</li>
            </ul>
        </section>
    </aside>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article class="smaller">
        <pre class="prettyprint" data-lang="go">
func learnTypes() {
    f := 3.14195 // float64, an IEEE-754 64-bit floating point number
    c := 3 + 4i  // complex128, represented internally with two float64s

    // Arrays have size fixed at compile time.
    var a4 [4]int           // an array of 4 ints, initialized to all 0
    a3 := [...]int{3, 1, 5} // an array of 3 ints, initialized as shown

    // Slices have dynamic size.  Arrays and slices each have advantages
    // but use cases for slices are much more common.
    s3 := []int{4, 5, 9}    // compare to a3.  no ellipsis here
    s4 := make([]int, 4)    // allocates slice of 4 ints, initialized to all 0
    bs := []byte("a slice") // type conversion syntax

    // Maps are a dynamically growable associative array type, like the
    // hash or dictionary types of some other languages.
    m := map[string]int{"three": 3, "four": 4}

    // …
}
        </pre>
    </article>
    <aside class="note">
        <section>
            <ul>
                <li>Zero-Value</li>
                <li><code>make</code> is magic</li>
                <li>This won’t compile, unused variables</li>
            </ul>
        </section>
    </aside>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="go">
func learnTypes() {
    // …

    // Unused variables are an error in Go.
    // The underbar lets you “use” a variable but discard its value.
    _, _, _, _, _, _, _, _, _ = s2, g, f, u, pi, n, a3, s4, bs

    learnMemory()
}
        </pre>
    </article>
    <aside class="note">
        <section>
            <ul>
                <li>Annoying? Only when prototyping.</li>
            </ul>
        </section>
    </aside>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="go">
func learnMemory() {
    p, q := useMemory() // declares p, q to be type pointer to int.
    fmt.Println(*p, *q) // * follows a pointer.  This prints two ints.

    learnFlowControl()
}

// Go is fully garbage collected.  It has pointers but no pointer arithmetic.
// You can make a mistake with a nil pointer, but not by incrementing a pointer.
func useMemory() (*int, *int) {
    s := make([]int, 20) // allocate 20 ints as a single block of memory
    s[3] = 7             // assign one of them
    r := -2              // declare another local variable
    return &s[3], &r     // & takes the address of an object.
}
        </pre>
    </article>
    <aside class="note">
        <section>
            <ul>
                <li>Compiler proves, if allocation is safe on stack</li>
            </ul>
        </section>
    </aside>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="go">
func learnFlowControl() {
    // If statements require brace brackets, and do not require parens.
    // Formatting is standardized by the command line command “go fmt.”
    if false {
        // pout
    } else {
        // gloat
    }

    // …
}
        </pre>
    </article>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="go">
func learnFlowControl() {
    // …
    // Use switch in preference to chained if statements.
    x := 1
    switch x {
    case 0:
    case 1:
        // cases don't “fall through”
    case 2:
        // unreached
    }
    // …
}
        </pre>
    </article>
    <aside class="note">
        <section>
            <ul>
                <li>Explicit fallthrough</li>
            </ul>
        </section>
    </aside>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="go">
func learnFlowControl() {
    // …
    // Like if, for doesn't use parens either.
    for x := 0; x < 3; x++ { // ++ is a statement
        fmt.Println("iteration", x)
    }

    // For is the only loop statement in Go, but it has alternate forms.
    for { // infinite loop
        break    // just kidding
        continue // unreached
    }
    // …
}
        </pre>
    </article>
    <aside class="note">
        <section>
            <ul>
                <li><code>x++</code> is a statement</li>
            </ul>
        </section>
    </aside>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="go">
func learnFlowControl() {
    // …
    // As with for, := in an if statement means to declare and assign y first,
    // then test y > x.
    if y := expensiveComputation(); y > x {
        x = y
    }

    // …
}
        </pre>
    </article>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="go">
func learnFlowControl() {
    // …
    // Function literals are closures.
    xBig := func() bool {
        return x > 100 // references x declared in above switch statement.
    }
    x = 1e6
    fmt.Println("xBig:", xBig()) // true
    x /= 1e5                     // this makes x == 10
    fmt.Println("xBig:", xBig()) // false now

    learnInterfaces()
}
        </pre>
    </article>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="go">
// Define Stringer as an interface type with one method, String.
type Stringer interface {
    String() string
}
        </pre>
    </article>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="go">
// Define pair as a struct with two fields, ints named x and y.
type pair struct {
    x, y int
}

// Define a method on type pair.  Pair now implements Stringer.
func (p pair) String() string { // p is called the “receiver”
    // Sprintf is another public function in package fmt.
    // Dot syntax references fields of p.
    return fmt.Sprintf("(%d, %d)", p.x, p.y)
}
        </pre>
    </article>
    <aside class="note">
        <section>
            <ul>
                <li>There’s no <code>-&gt;</code> notation</li>
            </ul>
        </section>
    </aside>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="go">
func learnInterfaces() {
    // Brace syntax is a “struct literal.”  It evaluates to an initialized
    // struct.  The := syntax declares and initializes p to this struct.
    p := pair{3, 4}
    fmt.Println(p.String()) // call String method of p, of type pair.
    var i Stringer          // declare i of interface type Stringer.
    i = p                   // valid because pair implements Stringer
    fmt.Println(i.String())

    // Functions in the fmt package call the String method to ask an object
    // for a printable representation of itself.
    fmt.Println(p) // output same as above. Println calls String method.
    fmt.Println(i) // output same as above

    learnErrorHandling()
}
        </pre>
    </article>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="go">
func learnErrorHandling() {
    // “, ok” idiom used to tell if something worked or not.
    m := map[int]string{3: "three", 4: "four"}
    if x, ok := m[1]; !ok { // ok will be false because 1 is not in the map.
        fmt.Println("no one there")
    } else {
        fmt.Print(x) // x would be the value, if it were in the map.
    }
    // An error value communicates not just “ok” but more about the problem.
    if _, err := strconv.Atoi("non-int"); err != nil { // _ discards value
        // prints “strconv.ParseInt: parsing "non-int": invalid syntax”
        fmt.Println(err)
    }
    learnConcurrency()
}

        </pre>
    </article>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article class="smaller">
        <pre class="prettyprint" data-lang="go">
// c is a channel, a concurrency-safe communication object.
func inc(i int, c chan int) {
    c <- i + 1 // <- is the "send" operator when a channel appears on the left.
}

func learnConcurrency() {
    // Same make function used earlier to make a slice.  Make allocates and
    // initializes slices, maps, and channels.
    c := make(chan int)
    // Start three concurrent goroutines.  Numbers will be incremented
    // concurrently, perhaps in parallel if the machine is capable and
    // properly configured.  All three send to the same channel.
    go inc(0, c) // go is a statement that starts a new goroutine.
    go inc(10, c)
    go inc(-805, c)
    // Read three results from the channel and print them out.
    // There is no telling in what order the results will arrive!
    fmt.Println(<-c, <-c, <-c) // channel on right, <- is "receive" operator.

    learnMoreConcurrency()
}
        </pre>
    </article>
    <aside class="note">
        <section>
            <ul>
                <li>Channels preserve order, but no telling which goroutine runs first.</li>
            </ul>
        </section>
    </aside>
</slide>
<slide>
    <hgroup>
        <h2>Syntax speedrun</h2>
    </hgroup>
    <article class="smaller">
        <pre class="prettyprint" data-lang="go">
func learnMoreConcurrency() {
    c, cs, cc := make(chan int), make(chan string), make(chan chan string)
    go func() { c <- 84 }()       // start a new goroutine just to send a value
    go func() { cs <- "wordy" }() // again, for cs this time
    // Select selects a case at random out of the cases
    // that are ready to communicate.
    select {
    case i := <-c: // the value received can be assigned to a variable
        fmt.Printf("it's a %T", i)
    case <-cs: // or the value received can be discarded
        fmt.Println("it's a string")
    case <-cc: // usused channel, not ready for communication.
        fmt.Println("didn't happen.")
    }
    // At this point, one of the two goroutines started above has completed,
    // the other will remain blocked.
}
        </pre>
    </article>
</slide>
<slide class="segue dark nobackground">
    <aside class="gdbar"><img src="static/ioslide/images/google_developers_icon_128.png"></aside>
    <hgroup class="auto-fadein">
        <h2>pixel²</h2>
    </hgroup>
</slide>
<slide>
    <hgroup>
        <h2>Pixelpixel</h2>
    </hgroup>
    <article class="smaller">
        <img src="imgs/gonoob-pp.png" class="reflect">
    </article>
    <aside class="note">
        <section>
            <ul>
                <li>A pixel made of pixels (256px × 256px)</li>
                <li>Drawable and clickable, each backed by a Go program</li>
                <li>Everyone gets a pixel for her-/himself</li>
                <li>Everyone can open this page</li>
            </ul>
        </section>
    </aside>
</slide>
<slide>
    <hgroup>
        <h2>Pixelpixel</h2>
    </hgroup>
    <article class="smaller">
        <img src="imgs/gonoob-pplogs.png" class="reflect">
    </article>
</slide>
<slide>
    <hgroup>
        <h2>Pixelpixel</h2>
    </hgroup>
    <article class="smaller">
        <img src="imgs/gonoob-ppcode.png" class="reflect">
    </article>
</slide>
<slide>
    <hgroup>
        <h2>Pixelpixel</h2>
    </hgroup>
    <article class="smaller">
        <img src="imgs/gonoob-ppfirst.png" class="reflect">
    </article>
</slide>
<slide>
    <hgroup>
        <h2>Picli</h2>
    </hgroup>
    <article>
        To get started, you only need <code>picli</code> installed.
        <ul>
            <li>Go to <a href="http://github.com/voxelbrain/pixelpixel">pixelpixel’s GitHub page</a></li>
            <li>Download the binary for your platform listed in the README</li>
            <li>Put it in your <code>$PATH</code></li>
        </ul>

        If you are one of the eager students and have (or going to have) the
        go toolchain installed, you can do:

        <pre class="prettyprint" data-lang="bash">
            go get github.com/voxelbrain/pixelpixel/picli
        </pre>
    </article>
</slide>
